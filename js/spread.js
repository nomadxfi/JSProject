'use strict';

/*Тема: Передача по ссылке и по значению.Spread оператор (ES6-ES9).

Когда работаем с примитивными данными (строки, числа, логич.значения) то они передаются по значению.
Когда работаем с объектами(массивы, ф-ции, специфич.объекты)то идет передача не по значению, а по ссылке.*/

/*********************************************************************************************************************/
//Поверхностные копии позволяют работать с теми св-ми которые лежат на 1м уровне:

// let a = 5,
// 		b = a; //(передача по значению)

// b = b + 5;

// console.log(a);
// console.log(b); //все отработало как предполагалось (b=5+5) т.е=10.

//создадим простой объект:

// const obj = {
//     a:5,
//     b:1
// }
//
// const copy = obj; //создаем копию объекта и проверяем будет ли это работать как с вариантом выше. (тут мы не копируем новый объект, а передаем значение по ссылке) Эта запись передает не саму структуру объекта, а передает ссылку на уже существующий объект
// copy.a = 10; //в этот скопированный объект в св-во 'a' помещаем 10. (модифицируя копию мы модицицируем изначальный объект потому что работаем не с копией, а с сылкой)
//
// console.log(obj); //в итоге в консоль выводятся два абсолютно одинаковых объекта, хотя модифицировали только копию
// console.log(copy);

//функция, которая при помощи цикла создаст новый объект уже перебирая старые св-ва, которые были в нашем объекте:
// function copy(mainObj) {
//     let objCopy = {}; //новый объект
//
//     let key; //переменную key можно создать и вне перебирающей кнструкции
//     for (key in mainObj) { //перебирающая конструкция 'for in'
//         objCopy[key] = mainObj[key]; //Пройдемся на старому объекту, скопируем все св-ва которые там есть и поместим в нашу новую копию, которая изначально была пустым обектом.
//     }
//
//     return objCopy; //возавращаем objCopy наружу чтобы дальше с ним взаимодействовать.
// }

// Протестируем нашу новую ф-цию:
// const numbers = { //тут создали переменную, которая называется numbers, это будет новый объект
//     a: 2, //создаем св-ва
//     b: 5,
//     c: { //св-во, которое будет вложенным объектом (чтобы проверить как такой цикл работает с вложенными структурами)
//         x: 7,
//         y: 9,
//     }
// }
//
// const newNumbers = copy(numbers); //Создаем новую переменную newNumbers (чтобы можно было подвязываться) и вот теперь воспользуемся функцией copy. Запускаем ф-цию и во внутрь передаем numbers 'copy(numbers)' И вот теперь готово клонирование объекта

// newNumbers.a = 10; //обращаемся к newNumbers и св-ву 'a' и помещаем туда 10.
// newNumbers.c.x = 22; //тоже сработает поверхностная копия (т.к вложенный объект передается как ссылка, а не по значению)


// console.log(newNumbers) //смотрим в консоли результат (скопированный объект с 10-кой)
// console.log(numbers) //смотрим изменяется ли изначальная конструкция (базовый объект, который не изменился)
/*********************************************************************************************************************/

// Использование объекта object.assign:

// const add = {
//     d: 17,
//     e: 20,
// };

// console.log(Object.assign(newNumbers, add)); //соединяем 2 обекта add и numbers. Создали независимую поверхностую копию объекта.
// Первым агрументом передаем тот объект, в который все это хотим поместить.

// Чтобы создать просто копию объекта:
//  console.log(Object.assign(newNumbers, add)); //Заменяем numbers на пустой объект
//чтобы это протестировать результат этой команды помещаем в новый объект:
// const clone = Object.assign({}, add);
//берем клон обращаемся к св-ву 'd' и заменяем его на 55
// clone.d = 55;
// проверяем изменения:
// console.log(add);
// console.log(clone);

/*********************************************************************************************************************/
// Сделаем копию массива:

// const oldArray = ['a','z','y']; //создадим изначальный массив с данными
// const newArray = oldArray.slice(); //метод, который копирует старый массив. создааем новую переменную newArray обращаемся к oldArray и для того чтобы создать копию ставим . и прописываем slice
//
// newArray[1] = 'abra'; // в newArray поменяем знаечение 2-го элемента
//
// //проверим результат как это работает: Получаем 2 разных массива
// console.log(newArray);
// console.log(oldArray);


/*********************************************************************************************************************/
//4-й способо создания поверхностной копии - оператор разворота spread (разворачивает структуру и превращает ее в набор каких-то данных)

// const video = ['youtube', 'vimeo', 'netflix'],
//          blogs = ['wordpress', 'tilda', 'github'],
//          internet = [...video, ...blogs, 'instagram', 'facebook', 4, null]; //spread пишется как ...(троеточие)в данной переменной будет содержаться все значения выше + несколько своих
//
// //Протестируем как это сработало:
// console.log(internet);


// function log(a, b, c) {
//     console.log(a);
//     console.log(b);
//     console.log(c);
// }
//
// const num = [2,5,7]; //массив разложится на 3 отдельных аргумента с помощью оператора spread
//
// log(...num); //функия отработала и каждый аргумент вывелся
//

//Создаем копию массива не с помощью slice, а с помощью оператора spread

const array = ['a', 'b'];

const newArray = [...array]; //все что нужно сделать (...array) Теперь в переменной newArray лежит новая копия этого массива

newArray[2] = 45; //поменяем в массиве значение элемента
console.log(newArray); //выведем результат с новым массивом
console.log(array); //выведем результат с старым массивом

//Создадим копию объекта(работает так же):
const defObj = {
    one: 1,
    two: 2,
    three: 3,
}

const newObj = {...defObj};
newObj.one = 1000;

console.log(newObj);
console.log(defObj);