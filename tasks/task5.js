'use strict';

/*********************************************************************************************/
//Какое будет выведено значение:
let x = 5; console.log(x++); //выводит 5 т.к знак инкремента обычно записывается до переменной

/*********************************************************************************************/
//Чему равно такое выражение:
let y = [] + false - null + true; // выводит NaN / массив будет приведен к пустой строке. если конкотенируем строку с каким-либо другим типом данных то всегда получаем строку.
console.log(typeof ([]+false)) //получается строка false
console.log('false' - null) //когда от строки отнимаем то выводится спец.значение NaN, которое получается при выполнении не математич.операций
console.log(NaN + true) //ничего не меняется
console.log(y);

/*********************************************************************************************/
// Что выведет этот код:
let a = 1; let b = a = 2; console.log(b); //выводит 2
//т.к число это примитив.тип данных, то идет цепочка справа налево.

/*********************************************************************************************/
//Чему равна сумма [] + 1 + 2
console.log([] + 1 + 2); //получается '12' как обычная строка (массив будет приведен как пустая строка и далее все складывается как строки )

/*********************************************************************************************/
//Что выведет этот код: alert( "1"[0] ) //получаем 1.
console.log("1"[0]); //строка и индекс. каждому элементу строки можно обратиться по его индексу.
console.log("12345"[2]); //получается 3, как и должно по его индексу.

/*********************************************************************************************/
// Чему равно 2 && 1 && null && 0 &&
//И запинается на лжи!!!
console.log(2 && 1 && null && 0 && undefined); //получается null
// логический оператор && всегда запинается на лжи. т.е выведет 1й элемент который будет false и далее код не идет.

/*********************************************************************************************/
//Есть ли разница между выражениями? !!( a && b ) и (a && b)?
console.log(!!( 1 && 2 ) === ( 1 && 2 )); //разница есть. 1-е значение это boolean а 2-е number. при сравнении получаем false. !! превращают следующее за ними значение в boolean
console.log(typeof !!( 1 && 2 )); //boolean
console.log(typeof( 1 && 2 )); //number

/*********************************************************************************************/
//Что выведет этот код: alert( null || 2 && 3 || 4 );
//ИЛИ запинается на правде!!!
console.log((null || 2 && 3 || 4)); //выводит 3 (впорос читается как: (2 или 3));
//по таблице приоритета операторов И выполняется раньше чем ИЛИ. возвращает последнее правдивое значение

/*********************************************************************************************/
//Правда ли что a == b ?
a = [1, 2, 3]; b = [1, 2, 3];  //false
const e =  [1, 2, 3]; //это разные хранилища информации с похожим содержимым
const f = [1, 2, 3];

/*********************************************************************************************/
//Что выведет этот код: alert( +"Infinity" );
console.log(+"Infinity"); //код выведет строку Infinity (но, тип данных число тк стоит унарный +).
console.log(typeof (+"Infinity"));

/*********************************************************************************************/
//Верно ли сравнение: "Ёжик" > "яблоко"?
//Для решения этой задачки нужна таблица символов Unicode
//Js сравнивает строки поочередно по UTF таблице ("ё" => по UTF таблице 1105,"я" => UTF dec(1103))
console.log("Ёжик" > "яблоко"); //false //Ё = 1025, я = 1103
console.log("ёжик" > "яблоко"); //true //ё = 1105, я = 1103
console.log("Ёжик" > "ёжик"); //false
console.log("ёжик" > "Ёжик"); //true

/*********************************************************************************************/
//Чему равно 0 || "" || 2 || undefined || true || false
console.log(0 || "" || 2 || undefined || true || false); //выведет 2.
//ИЛИ запинается на правде. 0 - false, "" - false, 2 - правда.